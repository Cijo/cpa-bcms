'use strict';

const fs = require('fs');
const { Kafka } = require('kafkajs');

class Producer {
	constructor(options = {}) {
		this.kafka = options.kafka;
		this.producer = options.kafka.producer();
	}

	async connect() {
		return await this.producer.connect();
	}

	async disconnect() {
		return await this.producer.disconnect();
	}

	async send(topic, message, options = {}) {
		const response = await this.producer.send({
			topic: topic || options.topic,
			messages: [{ value: JSON.stringify(message) }]
		});
		return response;
	}
}

class Consumer {
	constructor(options = {}) {
		this.kafka = options.kafka;
		this.consumer = options.kafka.consumer({
			...options.consumerOptions
		});
	}

	async subscribe(topic, options = {}) {
		return await this.consumer.subscribe({
			topic,
			...options
		});
	}

	async run(options = {}) {
		await this.consumer.run(options);
	}

	async connect() {
		return await this.consumer.connect();
	}

	// TODO
	async disconnect() {
	}
}

module.exports = class {
	
	constructor(options = {}) {
		this.certs = `${__dirname}/../certs`;
		this.kafka = new Kafka({
			brokers: options.hosts,
			ssl: {
				rejectUnauthorized: false,
				ca: [
					fs.readFileSync(`${this.certs}/ca.pem`).toString()
				],
				key: options.clientKey,
				cert: options.clientCert || fs.readFileSync(`${this.certs}/client.pem`).toString(),
				passphrase: options.pass
			}
		});
		this.producer = new Producer({ kafka: this.kafka });
		if (options.consumerOptions) {
			this.consumer = new Consumer({ kafka: this.kafka, consumerOptions: options.consumerOptions });
		}
	}

	async send(topic, message) {
		await this.producer.connect();
		await this.producer.send(topic, message);
		await this.producer.disconnect();
	}

};

